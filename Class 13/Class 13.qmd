---
title: "Class 13 (Transcriptomics and the analysis of RNA-Seq data)"
author: "Destiny (A16340362)"
format: pdf
---

The data for this hands-on session comes from a published RNA-seq experiment where airway smooth muscle cells were treated with **dexamethasone** (dex), a synthetic glucocorticoid steroid with anti-inflammatory effects (Himes et al. 2014).

```{r}
# Complete the missing code
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <-  read.csv("airway_metadata.csv")
```

```{r}
head(counts)
```

>Q1. How many genes are in this dataset? 

```{r}
nrow(counts)
```


>Q2. How many ‘control’ cell lines do we have? 

```{r}
table(metadata$dex)
```

```{r}
sum(metadata$dex== "control")
```

## Toy differential gene expression

Lets start by calculating the mean counts per gene in the "control" samples. We can then compare this value for each gene to the means counts in the "treated" samples (i.e. columns)

-Step 1. Find which columns in the `counts` correspond to the "control" samples
-Step 2. Calculate the mean value per gene in these columns. 
-Step 3. Store my answer for later in `control.mean`


```{r}
control.inds <- metadata$dex=="control"
```

```{r}
metadata[control.inds,]
```

```{r}
control.counts <- counts[, control.inds]
head(control.counts)
```
>Q3. Using `rowMeans()` or `rowSums` is a way to help make the code more robust, but you could also do this:

```{r}
#apply(control.counts, 1, mean)
control.mean <- rowMeans(control.counts)
```

>Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

```{r}
treated.inds <-metadata$dex=="treated"
```

```{r}
 treated.counts <-counts[, treated.inds]
```

```{r}
treated.mean <-rowMeans(treated.counts)
```

To keep us tidy, lets put our `control.mean` and `treated.mean` vectors together as two columns of a new data.frame

```{r}
meancounts <- data.frame(control.mean, treated.mean)
```

```{r}
head(meancounts)
```
```{r}
plot(meancounts)
```

```{r}
library(ggplot2)
```
>Q5.

```{r}
ggplot(meancounts) + aes(x=control.mean, y=treated.mean)+ geom_point(alpha=0.2)
```

>Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this?

```{r}
plot(log(meancounts))
```

```{r}
plot(meancounts, log="xy")
```

Log transformations are super useful when our data is skewed and measured over a wide range like this. We can use different log transformations like base10 or natural logs, but we most often prefer log2 units.

```{r}
#Control/Treated
log2(10/10)
```

What if there was a doubling?
```{r}
#Treated/Control
log2(20/10)
```
Half counts
```{r}
log2(10/20)
```

```{r}
log2(40/10)
```

Lets add a log2 fold change column to our little `meancounts` data.frame
```{r}
meancounts$log2fc <- log2(meancounts$treated.mean/ meancounts$control.mean)

head(meancounts)
```

There are some weird results like Nan ("not a number") and -Inf ("minus infinity")

```{r}
to.rm.inds <- rowSums(meancounts[, 1:2]==0) >0
mycounts <- meancounts[!to.rm.inds, ]
```


the `!` make flips TRUE values to FASLSE and vice versa
```{r}
dim(mycounts)
```

```{r}
head(mycounts)
```
>Q7. 

The purpose of the arr.ind argument in the which() is to tell us which values are TRUE in the columns and rows. We could then take the first column of the output and need to call the unique() in order to make sure we don't call the same row twice is if it has 0 in both samples.


```{r}
up.ind <- mycounts$log2fc > 2
down.ind <- mycounts$log2fc < (-2)
```

>Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level? 


```{r}
sum(up.ind)
```

>Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level?

```{r}
sum(down.ind)
```

>Q10. Do you trust these results? Why or why not?

No because we haven't done anything to figure out statisfical significance 

But we forgot all about statistical significance of these differences...

We will use DESeq2 to do this analysis properly..

##Using DESeq2

```{r}
library(DESeq2)
```

```{r}
dds <- DESeqDataSetFromMatrix(countData = counts, 
                     colData = metadata,
                     design = ~dex)
```

Now we can run our DESeq analysis 
```{r}
dds <- DESeq(dds)
```
```{r}
res <- results(dds)
head(res)
```
#A summary results plot

Volcano plot
This is a common type of summary figure that keeps both our inner biologist and inner stats nerd happy because it shows both p values and Log2(Fold-Change)

```{r}
plot(res$log2FoldChange, -log(res$padj), ylab="-Log(P-value)", xlab="Log2(Fold-Change)", col="pink" )

abline(v=2, col="red")
abline(v=-2, col="red")
abline(h=-log(0.05), col="blue")
title(main="Plot of DESeq results")
  
```





Save our results to date

```{r}
write.csv(res, file="deseq_results.csv")
```

##8. Adding annotation data

Our result table so far only contains the Ensembl gene IDs. However, alternative gene names and extra annotation are usually required for informative interpretation of our results. In this section we will add this necessary annotation data to our results.

```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")
```

```{r}
columns(org.Hs.eg.db)
```

The main function we will use here is called `mapIds()`
This function will indicate R identifiers 

Our current IDs are here:
```{r}
head(rownames(res))
```

These are in ENSEMBLE format. I want "SYMBOL" ids:

```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",   # The format of our genenames
                     column="SYMBOL",     # The new format we want to add
                     multiVals="first")
head(res)
```
Let's add GENENAME 
```{r}
res$genename <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",   # The format of our genenames
                     column="GENENAME",     # The new format we want to add
                     multiVals="first")
head(res)
```

```{r}
res$entrez <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")
head(res)
```
## Pathways analysis 

We'll use the *gage** package along with **pathways** here to do gene set enrichment (aka pathways analysis) and figure generation respectively 

```{r}
#/message: false 
library(pathview)
library(gage)
library(gageData)
```

Lets have a peak at the furst two pathways in KEGG
```{r}
data(kegg.sets.hs)

# Examine the first 2 pathways in this kegg set for humans
head(kegg.sets.hs, 2)
```

What we need is for `gage()` is our gene in ENTREZ id format with a measure of their impoartance

It wants a vector of e.g. fold changes. 

```{r}
foldchanges <- res$log2FoldChange
head(foldchanges)
```
Add ENTREZ ids as `names()` to my `foldchanges` vectors 
```{r}
names(foldchanges) <- res$entrez
head(foldchanges)
```

Now we can run `gage()` with this input vector and the geneset we want to examine for overlap/ enrichment 

```{r}
# Get the results
keggres = gage(foldchanges, gsets=kegg.sets.hs)
```

Look at the results 
```{r}
attributes(keggres)

```

```{r}
head(keggres$less)
```
We can view these pathways with our geneset genes highlighted using the `pathview()` function. E.g. for Asthma I'll use the pathway.id () (hsa05310) as seen above

```{r}
pathview(gene.data=foldchanges, pathway.id="hsa05310")
```
![My genes involved in Asthma pathway](hsa05310.pathview.png)
